---

title: CVE-2025-26943 Analysis & POC
description: Security Vulnerability in WordPress Easy Quotes Plugin.
date: 2025-09-23 20:20:00 +0700
categories: [Vulnerabilities, CVE Analyst]
tags: [analyst, plugin, sqli]

---

The vulnerability exists in the **Easy Quotes** plugin for WordPress prior to version **1.2.3**. This could allow attackers to directly interact with your database, including but not limited to data theft.

* **CVE ID**: [CVE-2025-26943](https://www.cve.org/CVERecord?id=CVE-2025-26943)
* **Product**: [WordPress Easy Quotes Plugin](https://wordpress.org/plugins/easy-quotes/#description)
* **Vulnerability Type**: SQL Injection
* **Affected Versions**: <= 1.2.2
* **CVSS severity**: High (9.3)
* **Required Privilege**: Unauthenticated

---

## Requirements

* [**Local WordPress and Debugging**](https://w41bu1.github.io/posts/wordpress-local-and-debugging/)
* **Taskbuilder Plugin**:  v1.2.2(vulnerable) and v1.2.3(fixed)
* **diff tool**: **meld** or any other tool to compare and see differences between the two versions

---

## Analysis

The application directly injected user input into an SQL query **without using safeguards**, leading to an SQL Injection vulnerability.

### Patch Diff

Use any diff tool to compare the vulnerable and patched versions.
A clear difference can be found in the file **includes/quotes-data.php**:

```php
private static function get_family_data($family) {
    /** @var wpdb $wpdb */
    global $wpdb;
    $tablename = $wpdb->prefix . 'easy-quotes-families';
    return $wpdb->get_row("SELECT * FROM `".$tablename."` WHERE `family`='".$family."';");
}
```

The patch uses `$wpdb->prepare()` instead of directly injecting user input into the query:

```php
private static function get_family_data($family) {
    /** @var wpdb $wpdb */
    global $wpdb;
    $tablename = $wpdb->prefix . 'easy-quotes-families';
    $sql = $wpdb->prepare(
        "SELECT * FROM %i WHERE `family` = %s",
        $tablename, $family
    );
    return $wpdb->get_row($sql);
}
```

![patch diff](images/posts/2025-09-03-CVE-2025-26943/patch_dif.png)

Several other functions were patched the same way, such as:
`get_font_variant($family_id, $variant_id)`, `get_font_variants($family)`, `get_fonts($category = -1)`

Although `get_fonts_categories()` was also patched, it did not handle user input, so it was not a concern:

```php
public static function get_fonts_categories() {
    /** @var wpdb $wpdb */
    global $wpdb;
    $tablename = $wpdb->prefix . 'easy-quotes-categories';
    $sql = $wpdb->prepare(
        "SELECT `category_id`, `category` FROM %i",
        $tablename
    );
    return $wpdb->get_results($sql);
}
```

### How it works

The SQL Injection resides in `get_family_data($family)`, and similar logic applies to other functions.

`get_family_data()` is a private method inside the `Quotes_Data` class:

```php
class Quotes_Data
{
	function __construct()
	{
		add_filter('posts_where', array($this, 'posts_where'), 10, 2);
	}

    // other function

	public static function get_font_variants($family) {
		$familyData = self::get_family_data($family);
        // other logic
	}

	public static function get_family($family, $variant_id) {
		$family_data = (array)self::get_family_data($family);
        // other logic
	}

	private static function get_family_data($family) {
		/** @var wpdb $wpdb */
		global $wpdb;
		$tablename = $wpdb->prefix . 'easy-quotes-families';
		return $wpdb->get_row("SELECT * FROM `".$tablename."` WHERE `family`='".$family."';");
	}
}
```

`get_family_data()` is called by both `get_family()` and `get_font_variants()`. To locate where they’re used, we can search using the keywords `get_family` or `get_font_variants`:

![search func](images/posts/2025-09-03-CVE-2025-26943/search_func.png)

The method `get_font_variants()` is invoked in the `rest_route_callback_font_variants()` method of the `Quotes_Rest_Route` class:

```php
class Quotes_Rest_Route
{
    function __construct()
    {
        add_action('rest_api_init', array($this, 'rest_api_init'));
    }

    /**
     * Register my REST route
     *
     * @return void
     */
    function rest_api_init($wp_rest_server)
    {
        $args = [
        'method'                => WP_REST_Server::READABLE,
        'callback'              => [$this, 'rest_route_callback_quote'],
        'permission_callback'   => '__return_true'
        ];
        register_rest_route('layart/v1', '/quote', $args);

        // other logic

        $args['callback'] = [$this, 'rest_route_callback_font_variants'];
        register_rest_route('layart/v1', '/font-variants', $args);
    }

    // other function

    function rest_route_callback_font_variants(WP_REST_Request $request)
    {
        $family = $request->get_param('family');
        $family = isset($family) ? $family : "Shadows Into Light";

        $response = Quotes_Data::get_font_variants($family);
        return rest_ensure_response($response);
    }
}
```

The constructor of `Quotes_Rest_Route` uses `add_action(hook_name, callback)` with `hook_name` set to `rest_api_init` to register custom endpoints with WordPress’s REST API system.

The callback `rest_api_init` repeatedly uses `register_rest_route` to create endpoints under the `layart/v1` namespace.

`rest_route_callback_font_variants` serves as the callback for the endpoint:

```
/wp-json/layart/v1/font-variants?family=family_name
```

If no `family` parameter is provided, the default value is `"Shadows Into Light"`.

---

## Exploit

### Detect SQLi

We attempt **Boolean-based SQL Injection** to test whether the `family` parameter is injectable.

**True request**:
![True request](images/posts/2025-09-03-CVE-2025-26943/true_req.png)

Executed query:

```sql
SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+'1'='1'"
```

Since `AND '1'='1'` is always true, the query is valid and returns normal data.

**False request**:
![False request](images/posts/2025-09-03-CVE-2025-26943/false_req.png)

Executed query:

```sql
SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+'1'='2'"
```

Since `AND '1'='2'` is always false, the query returns `[]`.

### Get First Letter of Database Name

To **dump all data**, it’s essential to first extract at least one character of the database name.

> In this case, the database name is **wordpress**, so the first letter is `w`.

![First letter](images/posts/2025-09-03-CVE-2025-26943/first_letter.png)

The response returns valid data, confirming the first character is `w`.

Executed query:

```sql
SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+SUBSTRING(DATABASE(),1,1)='w'"
```

---

## Conclusion

The **CVE-2025-26943** vulnerability in the WordPress **Easy Quotes** plugin before version **1.2.3** stems from not using query preparation (`$wpdb->prepare`) and directly concatenating user input into SQL statements, leading to SQL Injection.

The official patch replaces string concatenation with `$wpdb->prepare`, ensuring safer input handling.

**Key takeaways**:

* Always use `$wpdb->prepare()` when working with databases in WordPress to prevent SQL Injection.
* Regularly update plugins and perform security audits to avoid becoming a target.

---

## References

[SQL Injection cheat sheet - PortSwigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)

[WordPress Easy Quotes Plugin <= 1.2.2 is vulnerable to SQL Injection](https://patchstack.com/database/wordpress/plugin/easy-quotes/vulnerability/wordpress-easy-quotes-plugin-1-2-2-sql-injection-vulnerability)

---
